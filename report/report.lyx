#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\usepackage{multirow}
\usepackage{graphicx}
\newcommand{\terminaltext}[1]{{\footnotesize \colorbox{black}{\color{green}\texttt{#1}}}}
\graphicspath{ {images/} }
\usepackage{harvard}
\usepackage{url}
\usepackage{hyperref}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement h
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Modelling of non-hero vegetation in Houdini
\begin_inset Newline newline
\end_inset


\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Author
Marta Feriani
\begin_inset Newline newline
\end_inset

s4900092
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace vfill
\end_inset


\begin_inset Graphics
	filename images/BUlogo.png

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset FloatList figure

\end_inset


\begin_inset CommandInset toc
LatexCommand lstlistoflistings

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Abstract

\lang english
Vegetation modelling plays a key role in shots composition.
 Achieving a believable and nature-like result has proven to be a tedious
 and time consuming task for artists.
 To overcome this issue we present a Houdini tool for trees modelling.
 Through specifying different parameters' values the tool will generate
 a variety of tree species.
 Tree structures are achieved using the space colonization algorithm by
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

.
 Model parameters are directly mapped onto visual characteristics and offer
 an appropriate control over the silhouette and branching structure.
 This project shows that the toolset can produce a reasonable variety of
 trees.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Section

\lang english
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fearing]{Fearing (2000)}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Vegetation plays a key role in the composition of a shot.
 Arrangement of trees and the choice of specific species can help conveying
 a particular mood and help defining the staging of a particular scene.
 The aim set for vegetation can vary greatly between different movies.
 For The Jungle Book, for example, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fchwank2016]{MPC (2016)}
\end_layout

\end_inset

 built a sophisticated pipeline to build visually rich and realistic environment
s relying on both photogrammetry and 3D software as SpeedTree and Maya.
 Even though the aim was high quality realistic look, the pipeline also
 integrates tools 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:melson2016]{Melson et al 2016}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:cieri2016]{Cieri et al 2016}
\end_layout

\end_inset

 that allow for art-directing such vegetation.
 The final look achieves both goals of realism and artistic staging of vegetatio
n.
\end_layout

\begin_layout Standard
Sometimes, for animated movies, realism is not such as a primary target
 as the possibility of art-directability is.
 For the Last Bastion animated short by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:houdini2017]{Blizzard Animation (2017)}
\end_layout

\end_inset

, the studio designed a complete toolset to handle vegetation scattering
 and simulations using plant models created in Maya.
\end_layout

\begin_layout Standard
In many animated movies from Disney, as well, vegetation plays a key role
 throughout the story.
 Zootopia mesmerizing landscapes were built with Disney in-house procedural
 vegetation modelling tool 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:keim2016]{Bonsai (Keim, 2016)}
\end_layout

\end_inset

.
 Their tool managed to produce variation not just across species but within
 the same tree or bush specie as well.
 All vegetation models are also able to interact with the main characters
 or with external forces such as wind.
\end_layout

\begin_layout Standard
Being the aim of this project the sole modelling of procedural vegetation,
 in particular trees and with a specific preference for art-directability
 over realism, the main inspiration was found in Tangled 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:shek2010]{(Shek, 2010)}
\end_layout

\end_inset

.
 For the production of this animated movie, Disney developed a whole new
 engine that uses an artist sketched branches hierarchy and a rough shape
 for the crown to produce procedural tree modules.
 Unfortunately no further details are given about how Dendro inner algorithm
 calculates new branches.
 This project aims to reproduce a tool that offers similar feature to Disney
 Dendro Engine.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/MPM.png
	lyxscale 50
	width 90col%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\lang english
MPM
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:MPM"

\end_inset

MPM method as implemented by 
\lang british

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:stomakhin]{Stomakhin et al (2013)}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Related Works
\end_layout

\begin_layout Standard
Modelling natural shapes such as trees is difficult because of the richness
 of small details.
 The history of 3D tree modelling starts with a recursive algorithm proposed
 by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:honda1971]{Honda (1971)}
\end_layout

\end_inset

.
 The recursive structure relies on a few geometrical attributes such as
 branching angles and length ratio between consecutive segments.
 Honda also studies the nature of tree branching addressing the monopodial
 branching pattern shown in 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Branching-pattern"

\end_inset

as a special case for the dichotomous branching for structures that are
 parallel to the gravity.
 Honda's recursive approach has been at the core of many later modelling
 algorithms.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Branching pattern
\begin_inset CommandInset label
LatexCommand label
name "fig:Branching-pattern"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:lindenmayer1996]{Lindenmayer (1996)}
\end_layout

\end_inset

 introduced a string rewriting system know as L-System to describe cellular
 interactions.
 An L-System (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:L-Systems"

\end_inset

) is a formal grammar that consists of an alphabet, production rules and
 an axiom.
 The alphabet is a collection of symbols that can be used to produce strings.
 Production rules expand each symbol or string into some larger string.
 The axiom is used as starting point for the production.
 The string produced by iterating over the axiom can be later interpreted
 as geometric commands.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:lindenmayer1996]{Prusinkiewicz (1996)}
\end_layout

\end_inset

 applies Lindenmayer rewriting system to plants structures adding few extensions
 such as context sensitivity and random variations.
 L-Systems produce good results but the self similarity and the production
 patterns remain clearly visible in the final model.
 To overcome the pattern visibility, literature 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:lindenmayer1996]{(Prusinkiewicz, Lindenmayer (1996)}
\end_layout

\end_inset

 has introduced stochastic L-System which involves the selection of a production
 rule from the set based on a probability value.
 Other improvements on L-Systems involve the definition of a container volume
 for the L-System to grow into 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:ijiri2006]{(Ijiri et al, 2006)}
\end_layout

\end_inset

.
 Given the volume and an initial segment, the system will automatically
 set the depth for the recursion.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:oppenheimer1986]{Oppenheimer (1986)}
\end_layout

\end_inset

also relies on Honda recursive approach by developing natural patterns using
 fractals 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Fractals"

\end_inset

.
 The fractal specification is based on parameters such as branching angles,
 branch-to-parent size-ratio and branch-per-stem number.
 The fractal method by Oppenheimer was found to be affected by severe self
 similarity pattern visibility which gave the final shape a machine-made
 look.
 To overcome this problem 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Weber and Penn (1995)}
\end_layout

\end_inset

 improved the recursive model by adding randomness and organized functions
 to affect the tree development.
\end_layout

\begin_layout Standard
The interpretation of a tree as a recursive structure is justified by the
 process of tree development but plays a smaller role for fully grown trees.
 Buds may have different fate such as growing to major limbs, being shed
 or remaining small twigs.
 In the architecture of a mature tree, therefore, the regularity of the
 recursive branching is mainly lost, overridden by subsequent development
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{(Weber and Penn 1995)}
\end_layout

\end_inset

.
 Furthermore, finding rules and fitting parameters for recursive structures
 is a non trivial task.
 A small variation on the initial conditions will propagate exponentially
 through the generations becoming more and more evident, to the point that
 trying to tweak the existing rules to produce small variations on the produced
 model will often lead to a drastically different whole new structure.
 Given the recursive nature of both L-System and fractals, even the use
 of random variables cannot completely overcome self-similarity issue and
 the resulting architectures give the machine-made impression (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:rodkaew2003]{Rodkaev et al, 2003}
\end_layout

\end_inset

).
 
\end_layout

\begin_layout Standard
New techniques for 3D tree modelling find common ground in the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2005]{Runions et al (2005)}
\end_layout

\end_inset

 approach developed for leaves venation.
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

 inherit Runions approach and apply it to a new algorithm based on particles
 that produces realistic leaves venation on a 2D space or a branching structure
 in a 3D space.
 Rodkaev populates a shape or a volume with particles.
 Each particle will move towards a predefined goal position merging with
 neighbours particles when the distance is smaller than a certain threshold.
 The trail for the particles trajectories generates the tree graph.
\end_layout

\begin_layout Section
Technical background
\end_layout

\begin_layout Standard
Similar to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:weber1995]{Rodkaev et al (2003)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2007]{Runions et al (2007)}
\end_layout

\end_inset

 suggest a space colonization algorithm as an extension of the 3D leaves
 venation by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:runions2005]{Runions et al (2005)}
\end_layout

\end_inset

.
 Unlike Rodkaev's, Runions' branching structure is formed in a base-to-leaves
 order.
 Each iteration of the algorithm produces new elements that expand the tree
 structure formed in the previous steps.
 This approach results not only to be adaptive to obstacles and neighbour
 plants, but also provides controls over the growth process that results
 in a wide variety of tree structures.
\end_layout

\begin_layout Subsection
Overview
\begin_inset CommandInset label
LatexCommand label
name "subsec:Overview"

\end_inset


\end_layout

\begin_layout Standard
The algorithm proceeds as follows.
 A 3D envelope for the tree crown is specified as input.
 Its volume is seeded with a set of attraction points.
 The attraction points influence the growth of the tree structure by signalling
 the availability of empty space within the tree crown envelope.
 A single point is specified as input and acts as the base of the tree.
 Having the attracting points and the first tree point, the tree structure
 is generated as an iterative process.
 Each iteration produces new tree points in the direction of the neighbouring
 attraction points to extend the existing tree structure.
 The algorithm may stop after a user-defined number of iterations.
 If let running, the algorithm will either stop when there are no attraction
 points close enough to the tree to influence its growth (i.e.
 no tree points are within a threshold distance, called radius of influence,
 from the attraction points) or when all attraction points has been reached
 by tree points.
\end_layout

\begin_layout Standard
Further manipulation involves subdivision and smoothing of the internodes
 (branch that connects two consecutive nodes of the tree), skinning and
 scattering of organs such as leaves, flowers or fruits.
\end_layout

\begin_layout Subsection
Growth Algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:Growth-Algorithm"

\end_inset


\end_layout

\begin_layout Standard
Competition for space plays a fundamental role in the colonization algorithm
 and determines the branching pattern for the tree structure.
 Before delving into the details of the algorithm some definitions and axioms
 are needed.
\end_layout

\begin_layout Subsubsection
Definitions and axioms
\end_layout

\begin_layout Enumerate
Every point the algorithm uses is either a tree node or an attraction point.
 From now on we will refer to tree nodes with 
\begin_inset Formula $v$
\end_inset

 and attraction point with 
\begin_inset Formula $s$
\end_inset

.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $N$
\end_inset

 is the set of all the attraction points.
\begin_inset Formula 
\begin{equation}
\forall s,\,s\in N
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $T$
\end_inset

 is the set for the tree nodes
\begin_inset Formula 
\begin{equation}
\forall v,\,v\in T
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
If we refer to 
\begin_inset Formula $p$
\end_inset

 as a generic point in the algorithm
\begin_inset Formula 
\begin{equation}
\nexists p\mid p\in N\land p\in T
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $S(v)$
\end_inset

 is the set of attraction points 
\begin_inset Formula $s$
\end_inset

 that influence the growth of the tree point 
\begin_inset Formula $v$
\end_inset

 for the current iteration.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $d(a,b)$
\end_inset

 is the Euler distance between point 
\begin_inset Formula $a$
\end_inset

 and point 
\begin_inset Formula $b$
\end_inset

 
\begin_inset Formula 
\begin{equation}
d(a,b)=\sqrt{(a.x-b.x)^{2}+(a.y-b.y)^{2}+(a.z-b.z)^{2}}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $di$
\end_inset

 is the 
\shape italic
radius of influence
\shape default
 which represents the maximum distance between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $v$
\end_inset

 so that 
\begin_inset Formula $s\in S(v)$
\end_inset


\end_layout

\begin_layout Enumerate
\begin_inset Formula $dk$
\end_inset

 is the 
\shape italic
kill distance
\shape default
.
 If 
\begin_inset Formula $\exists v\in T\mid d(s,v)<dk$
\end_inset

, then 
\begin_inset Formula $s$
\end_inset

 is removed.
\end_layout

\begin_layout Enumerate
\begin_inset Formula $D$
\end_inset

 is the distance between consecutive nodes of the tree
\end_layout

\begin_layout Subsubsection
Steps
\begin_inset CommandInset label
LatexCommand label
name "subsec:Steps"

\end_inset


\end_layout

\begin_layout Enumerate
Define a 3D shape for the tree crown.
 Initialize the parameters 
\begin_inset Formula $N$
\end_inset

, 
\begin_inset Formula $di$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

, 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Enumerate
Populate the 3D envelope with attraction points using a certain random distribut
ion.
\end_layout

\begin_layout Enumerate
Define at least one tree node to act as the base of the tree structure.
\end_layout

\begin_layout Enumerate
Each attraction point 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in N$
\end_inset

 may influence the tree node 
\begin_inset Formula $v$
\end_inset

 that is closest to it.
 The influence occurs if 
\begin_inset Formula $d(s,v)<di$
\end_inset

.
 For each 
\begin_inset Formula $s\in N$
\end_inset

, check if there is any 
\begin_inset Formula $v\in T$
\end_inset

 that meets the condition.
 More than one attraction point may influence the same 
\begin_inset Formula $v$
\end_inset

 tree point: all the attraction points that influence 
\begin_inset Formula $v$
\end_inset

 are gathered in the 
\begin_inset Formula $S(v)$
\end_inset

 set.
\end_layout

\begin_layout Enumerate
For each tree node 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v\in T$
\end_inset

 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
, if 
\begin_inset Formula $S(v)$
\end_inset

 is not empty, a new tree node 
\begin_inset Formula $v^{\prime}$
\end_inset

is created.
 The new tree node lies at a distance 
\begin_inset Formula $D$
\end_inset

 from 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $v$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
\lang british
 in the direction of the average of the normalized vectors towards the attractio
n points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\lang english

\begin_inset Formula $s\in S(v)$
\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}\in T
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
d(v,v^{\prime})=D\label{eq:newborn_dir_magnitude}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\vec{n}=\sum_{s\in S(v)}\frac{s-v}{\shortparallel s-v\shortparallel}\label{eq:newborn_dir}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\hat{n}=\frac{\vec{n}}{\shortparallel n\shortparallel}\label{eq:newborn_dir_normal}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
v^{\prime}=v+D\hat{n}\label{eq:newborn_position}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
Perform a check to test if any attraction points 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $s\in N$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 should be removed.
 This happens if the following condition is true for at least one 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $v\in T$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
:
\begin_inset Formula 
\begin{equation}
d(s,v)<dk
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\lang english
repeat from steps 4 to 6 until the stopping conditions mentioned in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Overview"

\end_inset

 are met.
\end_layout

\begin_layout Standard

\lang english
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang english
Space Colonization Algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Standard
The network for the implementation of the growth algorithm relies on the
 layering of simple rules that eventually lead to the creation of the complexity
 that characterizes trees in nature.
 Houdini supports multiple scripting languages such as HScript, Python and
 VEX.
 Being Python widely used as scripting language and being a reality shared
 between many DCC software, it might seem the most sensible choice.
 On the other hand, VEX scripting language is the Houdini native language.
 VEX gives direct access to geometry data and provides a wide variety of
 built-in function optimized for best performances on the Houdini geometry
 internal representation.
 In terms of performances, VEX has proven to be faster than Python because
 it implements automatic multithreading while Python does not have the same
 feature.
 Given the marked difference in performance, VEX was used throughout this
 project.
\end_layout

\begin_layout Subsection
Wrangle Node
\begin_inset CommandInset label
LatexCommand label
name "subsec:Wrangle-Node"

\end_inset


\end_layout

\begin_layout Standard
The 
\family typewriter
Wrangle
\family default
 node 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:wrangle]{(SideFX, 2017)}
\end_layout

\end_inset

 is the most present node type in the network therefore it seemed only natural
 to give a brief explanation of how it works.
\end_layout

\begin_layout Standard
The 
\shape italic
Attribute Wrangle
\shape default
 is a low level node that allows for the tweaking of the geometry attributes
 using VEX code.
 Its capabilities correspond to the 
\shape italic
Attribute VOP SOP
\shape default
.
 The main difference between the two of them is that 
\shape italic
Wrangle
\shape default
 uses a a textual editor whilst the 
\shape italic
Attribute VOP SOP
\shape default
 uses a visual network.
\end_layout

\begin_layout Standard
The node can edit the input geometry by changing or adding attributes.
 It can also remove or create new geometry for example by adding points,
 linking points together to create polygons and so on.
 The snippet runs on details or on every point/primitive/vertex of the first
 input geometry.
 Using  multiple sources to the node it is also possible to access data
 from different geometry at the same time.
 When having multiple sources, only the first input geometry will be passed
 down to the next node of the network whilst the other input geometries
 will be lost.
\end_layout

\begin_layout Standard
When the snippet affects the attributes of the geometry, these attribute
 will not be available until the node is cooked.
 This often makes is difficult to populate geometry attributes such as arrays
 within the same 
\shape italic
Wrangle
\shape default
 node.
 For this reason the implementation of particular parts of the growth algorithm
 might not seem the most straightforward or obvious way to approach the
 problem, but have been deliberately designed to overcome this particular
 issue.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Wrangle node interface
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Data structure
\begin_inset CommandInset label
LatexCommand label
name "subsec:Data-structure"

\end_inset


\end_layout

\begin_layout Standard
The growth algorithm, as presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Growth-Algorithm"

\end_inset

, mostly relies on points position.
 Each point has certain attributes to make it possible to create the tree
 structure.
 The attribute 
\family typewriter
@type
\family default
 divides the point set in two main categories, respectively the tree nodes
 and the attraction points.
 Given the nature of the algorithm, the total number of attraction points
 will decrease each iteration whilst every new node that will be created
 will increase the count for the tree nodes.
 To give a better visualization for this partition, the colour attribute
 
\family typewriter
@Cd
\family default
 is initialized to 
\begin_inset Formula ${1,0.5,0}$
\end_inset

 for the tree node and to 
\begin_inset Formula ${0,0.5,1}$
\end_inset

 for the attraction points.
\end_layout

\begin_layout Standard
The aim of the algorithm is to create a believable branching structure to
 reproduce natural trees.
 Stems might either grow in a single direction or fork producing new stems.
 Older stems also grow thicker to balance the weight of the younger stems.
 This branching pattern can be represented by an acyclic graph data structure.
\end_layout

\begin_layout Standard
A 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:graph]{graph}
\end_layout

\end_inset

 is a finite collection of vertices and edges.
 Graphs are used to model pairwise relations between object.
 The vertices, or nodes, represent the objects while the edges are the relations.
 The different nature of the relations leads to different kinds of graphs.
 In the case of a directed graph, each edge has an orientation, from one
 vertex to another vertex.
 A path is a sequence of edges.
 A node 
\begin_inset Formula $A$
\end_inset

 is reachable by another node 
\begin_inset Formula $B$
\end_inset

 if there exists a path that leads from 
\begin_inset Formula $A$
\end_inset

 to 
\begin_inset Formula $B$
\end_inset

.
 If for each node in the graph there is no path that connects the node to
 itself, the graph is said to be 
\emph on
acyclic
\emph default
.
 Being a graph a hierarchical structure, it is appropriate to address relations
 between nodes as parent/child relations.
 Each node is therefore aware either of its parent, its children or both.
 In computer science relations between nodes are implemented by storing
 in each node a pointer to its connected ones.
 The network developed for this project provides each tree node with two
 attributes, an integer and an array, to store references to the parent
 and the children respectively.
 Unfortunately, Houdini does not have pointers-like structures.
 The points of a geometry are stored in an array-like structure.
 The 
\family typewriter
@ptnum
\family default
 attribute refers to the index of the point in that array.
 When referring to a point using the 
\family typewriter
@ptnum
\family default
 attribute, one can gain direct access to other attributes, either built-in
 or custom, of that point.
 Unfortunately, being the 
\family typewriter
@ptnum
\family default
 ultimately just an index in an array, its value is not consistent through
 the network.
 Operations such as adding or removing points or merging together two geometries
 may shift or offset the 
\family typewriter
@ptnum
\family default
 value.
 Given the unstable nature of 
\family typewriter
@ptnum, 
\family default
building parent/child relation upon it did not seem to be a suitable choice.
 As a workaround, each tree node also stores a unique identifier 
\family typewriter
@id
\family default
.
 Smaller 
\family typewriter
@id
\family default
 values belong to older tree nodes while greater values identify younger
 ones.
 When populating the 
\family typewriter
@parent
\family default
 and 
\family typewriter
@kids
\family default
 attributes, the reference to the other points will not be represented by
 
\family typewriter
@ptnum
\family default
 but by 
\family typewriter
@id
\family default
 instead.
 Having to rely on a custom attribute such as 
\family typewriter
@id
\family default
 automatically implies losing the direct access to the points granted by
 
\family typewriter
@ptnum
\family default
.
 This greatly affects the performances of the whole algorithm because in
 order to find a node with a specific 
\family typewriter
@id
\family default
 one has to cycle over each point of the geometry and check for a match.
 In order not to loose this convenient feature of direct access, every time
 the algorithm works on the tree nodes the 
\shape italic
Sort
\shape default
 node is used to remap 
\family typewriter
@ptnum
\family default
 based on the 
\family typewriter
@id
\family default
 value.
 This solution allows for a reliable hierarchy structure while maintaining
 speed of access.
\end_layout

\begin_layout Standard
Another important information about the tree nodes is the growth direction
 and the length of the internode (the distance between consecutive tree
 nodes).
 Storing this values make it possible for a  more detailed manipulation
 of branching angles at a later time.
 Each point therefore stores a 
\family typewriter
@growdir
\family default
 attribute that holds the normalized growth vector that links the parent
 to the node point position.
\end_layout

\begin_layout Standard
As a final step, each node also has two flags respectively for death and
 fertility.
 The fertility flag signals if the node can produce a child in the current
 iteration, and can therefore assume 
\begin_inset Quotes eld
\end_inset

non fertile
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

fertile
\begin_inset Quotes erd
\end_inset

 values in two consecutive iteration.
 On the other hand, when the death flag is set to 
\family typewriter
true
\family default
 it determines an irreversible condition for the node.
 A node dies whenever it reaches the maximum amount of children or in degenerate
 cases such as the position of the child node being coincident with its
 own position.
\end_layout

\begin_layout Standard
As the information needed on a per-node basis are quite important in terms
 of quantities, whenever an attribute is not needed any longer it is removed
 from the geometry.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Data Structure (Geometry Spreadsheet)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Parameter initialization
\end_layout

\begin_layout Standard
In order for the growth algorithm to start, some parameters have to be set
 such as the tree crown envelope, the attraction points position and the
 roots points.
\end_layout

\begin_layout Subsubsection
Tree crown
\end_layout

\begin_layout Standard
The network provides up to three different ways to specify the crown volume
 for the tree.
 All of them take as an input polygonal shapes that are later converted
 to a volume.
 In its very basic implementation, the user-specified tree crown is converted
 to a volume using the 
\shape italic
Isooffset
\shape default
 node.
 The conversion is necessary in order to populate the tree crown volume
 with the attraction points.
 Moving from the base implementation, the user can specify a collision object
 for the tree crown to interact with.
 This options makes it possible to simulate a tree growth process where
 the final shape is affected by surrounding obstacles.
 The collision object is first converted to a volume.
 To identify the viable area for the tree to grow, the 
\shape italic
volume mix
\shape default
 node performs a subtraction operation between the two input volumes.
 The resulting volume is then used for the tree to grow.
 Another option allows the user not to specify  tree crown volume directly,
 but it instead calculates the viable space for growth from a given object.
 The input geometry is converted to volume twice: the first conversion replicate
s the input geometry closely whilst the second one will inflate the volume
 with a user-defined offset.
 The difference between the volumes will create a layer wrapped around the
 initial object.
 This option can convey the illusion of a plant clinging and growing finding
 support on an object, like vines do.
\end_layout

\begin_layout Standard
Unfortunately the conversion from polygon to volume can produce artefacts
 due to the conversion method used by the 
\shape italic
Isooffset
\shape default
 node.
 Different workarounds to this problem have been tried but none of them
 proved to be successful for all kinds of input geometry.
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Collision Object
\end_layout

\end_inset

side by side first with geo, then with volumes
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Attraction Points
\end_layout

\begin_layout Standard
At early stages of the production, the volume obtained from the tree crown
 shape was seeded with uniformly distributed attraction points.
 The resulting trees, as described by Runions  shows a uniform density in
 the branches distribution.
 In many real trees and shrubs however the density increases near the crown
 surface due to better light exposure.
 To achieve the same result, following Runions suggestion, the attraction
 points in the network are seeded using a user-defined density profile,
 function of the distance from the outer surface of the tree crown.
 The steps to achieve such behaviour are explained below.
\end_layout

\begin_layout Standard
As a first step, the tree crown is seeded with attraction points using a
 uniform distribution.
 A 
\shape italic
Wrangle
\shape default
 node 
\begin_inset Quotes eld
\end_inset


\family typewriter
distance_from_bounding_object
\family default

\begin_inset Quotes erd
\end_inset

 evaluates, for each attraction point, the distance from the bounding object
 provided as a second input to the node.
 The resulting value is stored to an attribute named 
\family typewriter
@dist
\family default
.
 The 
\shape italic
promote
\shape default
 Houdini node is used twice to find respectively the maximum  
\family typewriter
@max_dist
\family default
 and the minimum value 
\family typewriter
@min_dist
\family default
 for the 
\family typewriter
@dist
\family default
 attribute.
 This information feeds a second 
\shape italic
Wrangle
\shape default
 node 
\begin_inset Quotes eld
\end_inset


\family typewriter
radial_distribution
\family default

\begin_inset Quotes erd
\end_inset

: each node's 
\family typewriter
@dist
\family default
 value is taken from its original range (
\family typewriter
@min_dist
\family default
, 
\family typewriter
@max_dist
\family default
) and re-scaled to its corresponding value in the new range 
\begin_inset Formula $(0,1)$
\end_inset

.
 The resulting variable is linked to a user-customizable ramp.
 The 
\begin_inset Formula $y-$
\end_inset

value of the ramp represents the probability for the attraction point to
 survive.
 A random number based on the 
\family typewriter
@ptnum
\family default
 of the current attraction point is calculated and compared to the probability
 value.
 If it results to be less, the attraction point gets removed.
 The ramp extends the potential of Runions idea by giving the users not
 only control over the density near the crown surface but providing them
 with a greater art-directability over the density of branches from the
 centroid of the tree crown shape to its boundaries.
\end_layout

\begin_layout Standard
The same principles are used to define a second custom distribution that
 uses the 
\begin_inset Formula $Y$
\end_inset

 coordinate of the point position instead of the distance from the object
 (in this case the nodes involved are called 
\begin_inset Quotes eld
\end_inset


\family typewriter
AP_height
\family default

\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset


\family typewriter
vertical_distribution
\family default

\begin_inset Quotes erd
\end_inset

).
 The newly generated attraction points are then initialized.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Attraction Points density distribution
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Roots
\begin_inset CommandInset label
LatexCommand label
name "subsec:Roots"

\end_inset


\end_layout

\begin_layout Standard
The network provides three different ways to specify the roots for the growth
 algorithm.
 A user can either create single root points by specifying the coordinates,
 input a pre-made set of points, or a trunk-and-branches curves structure.
\end_layout

\begin_layout Standard
For the first two options the initialization of the nodes attributes follows
 the same process.
 All the root points' 
\family typewriter
@parent
\family default
 is set to 
\begin_inset Formula $-1$
\end_inset

 to signal that they do not have any parent.
 As said before, the colour 
\family typewriter
@Cd
\family default
 is initialized to yellow 
\begin_inset Formula ${1,0.5,0}$
\end_inset

,  
\family typewriter
@kids
\family default
 is declared as an empty array, and 
\family typewriter
@type
\family default
 is initialized to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

.
 The parameters 
\family typewriter
@growdir
\family default
, 
\family typewriter
@n_dead
\family default
, and 
\family typewriter
@attr_dead
\family default
 are initialized to their default values, respectively 
\begin_inset Formula ${0,0,0}$
\end_inset

, 
\begin_inset Formula $0$
\end_inset

 (meaning that the node is alive) and 
\begin_inset Formula $-1$
\end_inset

.
\end_layout

\begin_layout Standard
The initialization of some attributes such as 
\family typewriter
@parent
\family default
, 
\family typewriter
@kids
\family default
 and 
\family typewriter
@type
\family default
 differs in the case where a custom trunk structure is fed in the system.
 This kind of structure already contains primitive information that link
 together points in a precise hierarchy.
 The most likely scenario is that each branch is represented as a curve
 primitive.
 The fork points of the structure will then belong to two different primitives
 at once, for example to both the trunk and a branch.
 The first attribute to be initialized is the 
\family typewriter
@kids
\family default
 array using the 
\begin_inset Quotes eld
\end_inset


\family typewriter
trunk_kids
\family default

\begin_inset Quotes erd
\end_inset

 snippet.
 This 
\shape italic
Wrangle
\shape default
 node is encapsulated in a 
\family typewriter
for
\family default
 loop nodes block that will iterate on each primitive of the input geometry.
 The 
\shape italic
Wrangle
\shape default
 will therefore process the points of one primitive at a time.
 In the 
\shape italic
Wrangle
\shape default
 interface, the snippet is set to 
\begin_inset Quotes eld
\end_inset

run over details
\begin_inset Quotes erd
\end_inset

 so that the iteration process over the points is explicitly declared in
 in the code.
 The snippet starts by retrieving an ordered array of the current primitive
 points.
 A 
\family typewriter
for
\family default
 loop then iterates over this array reading the point's
\family typewriter
 @ptnum
\family default
 value and assigning the next point in the array to itself as 
\family typewriter
@kids
\family default
 element.
 By using this approach, the snippet successfully handles specific cases
 in which the children to the point belong to different primitives.
 After having initialized the 
\family typewriter
@kids
\family default
 attribute, the 
\family typewriter
@parent
\family default
 is straightforward: the 
\begin_inset Quotes eld
\end_inset


\family typewriter
trunk_parent
\family default

\begin_inset Quotes erd
\end_inset

 
\shape italic
Wrangle
\shape default
 iterates over each point of the input geometry regardless of the primitive
 they belong to.
 Each point will read its own 
\family typewriter
@kids
\family default
 list and proceeds to set itself as 
\family typewriter
@parent
\family default
 attribute to these points.
 One can refer to this process as 
\begin_inset Quotes eld
\end_inset

parent injection
\begin_inset Quotes erd
\end_inset

.
 It is important to highlight that at this stage the 
\family typewriter
@id
\family default
 attribute described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Data-structure"

\end_inset

 has still not been initialized, and the parent-children relation is still
 built on the 
\family typewriter
@ptnum
\family default
.
 It is also important to understand that in this particular part of the
 network all the geometry being processed belongs to the tree structure.
 The 
\family typewriter
@id
\family default
 can be therefore initialized as a plain copy of the 
\family typewriter
@ptnum
\family default
.
 Being 
\family typewriter
@ptnum
\family default
 and 
\family typewriter
@id
\family default
 coincident at this stage, the initialization process described results
 to be correct.
 As a next step, the 
\family typewriter
@type
\family default
 has to be set.
 The implementation process makes sure that the user is given a certain
 extent of controls over the choice of root points for the growth algorithm.
 The network highlights as candidate roots all the points contained within
 the volume of the tree crown shape.
 The user can then decide which of them to keep.
 For the selected points, the 
\family typewriter
@type
\family default
 is set to 
\begin_inset Quotes eld
\end_inset

node
\begin_inset Quotes erd
\end_inset

 while the remaining ones are set to 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

.
 During the growth algorithm, only the nodes will interact while the others
 will be lifeless.
 A final attribute 
\family typewriter
@generation
\family default
 is initialized for all root points regardless of whether they are single
 points or points selected from a custom structure.
 This attribute plays a key role in a later part of the network to set and
 scale the cross section of the branches according to their age.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Roots initialization
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
pic of the network
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Growth
\end_layout

\begin_layout Standard
The growth main algorithm lies inside a dedicated subnetwork 
\begin_inset Quotes eld
\end_inset


\family typewriter
growing_alg
\family default

\begin_inset Quotes erd
\end_inset

.
 This subnetwork mainly consists of a 
\family typewriter
for
\family default
 loop that determines the number of time the geometry is processed.
 Contrary to the stop conditions presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Overview"

\end_inset

, the loop will only terminate after a user-defined number of iterations.
 It can happen that the user requires the algorithm to run more times than
 the ones required to meet the stop condition.
 In this case, even though the network will continue iterating, no new geometry
 is created.
 When running the algorithm, the user has also control over the values for
 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

 and 
\begin_inset Formula $di$
\end_inset

.
\end_layout

\begin_layout Standard
Before delving in the growth loop, the 
\shape italic
Wrangle
\shape default
 
\begin_inset Quotes eld
\end_inset


\family typewriter
AD_treepts
\family default

\begin_inset Quotes erd
\end_inset

 sets a detail attribute over the geometry that specifies the total number
 of tree nodes based on the 
\family typewriter
@type
\family default
 attribute of the points.
 This is later used to produce the 
\family typewriter
@id
\family default
 for the newborn nodes.
\end_layout

\begin_layout Standard
At this stage as well, points with type 
\begin_inset Quotes eld
\end_inset

trunk
\begin_inset Quotes erd
\end_inset

 are filtered out of the growth process and rejoined with the rest of the
 geometry when the process ends.
\end_layout

\begin_layout Standard
Shortly, at each iteration the growth algorithm needs to first find the
 set of attraction points (if any) that influence each fertile tree node,
 create new nodes in the direction determined by the influencing attraction
 points, and decide which attraction points will survive to the next iteration.
\end_layout

\begin_layout Subsubsection
Finding influencing attraction points
\begin_inset CommandInset label
LatexCommand label
name "subsec:Finding-neighbours"

\end_inset


\end_layout

\begin_layout Standard
The tree nodes and the attraction points are divided based on their 
\family typewriter
@type
\family default
 value.
 In order to keep the calculation as light as possible, a preparation step
 is undertaken using the 
\begin_inset Quotes eld
\end_inset


\family typewriter
find_influencing_attr
\family default

\begin_inset Quotes erd
\end_inset

 before finding the closest tree node of each attraction point.
 The 
\shape italic
Wrangle
\shape default
 receives as first input geometry the set 
\begin_inset Formula $N$
\end_inset

 of the attraction points and as second input the set 
\begin_inset Formula $T$
\end_inset

 of tree nodes.
 The node purpose is to isolate the attraction points that will influence
 the tree growth for the current iteration from the inert ones.
 The snippet is set to 
\begin_inset Quotes eld
\end_inset

run over details
\begin_inset Quotes erd
\end_inset

.
 Iterating over each tree node, a function 
\family typewriter
_setInfluencing()
\family default
 is invoked.
 The function takes as an input 
\family typewriter
a
\family default
 the position of the tree node.
 Based on that position, the function retrieves all the attraction points
 that are closer than the user-defined 
\begin_inset Formula $di$
\end_inset

 distance.
 Every attraction point that satisfies this condition is flagged as an influenci
ng node.
 The set of influencing nodes is therefore a subset of the set 
\begin_inset Formula $N$
\end_inset

 of all the attraction points.
 Using the 
\shape italic
blast
\shape default
 node, the influencing nodes are separated from the other inactive attraction
 points.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Visualization of the influencing nodes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
sia viewport che il wiring dei nodi
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The tree nodes and the influencing nodes are wired into the 
\begin_inset Quotes eld
\end_inset

f
\family typewriter
ind_neighbour
\family default

\begin_inset Quotes erd
\end_inset

 subnetwork.
 Each attraction point only influences the tree node closest to it.
 The search for the closest tree node is implemented in 
\begin_inset Quotes eld
\end_inset


\family typewriter
fast_search
\family default

\begin_inset Quotes erd
\end_inset

: the 
\family typewriter
wrangle
\family default
 takes as a first input geometry the tree nodes and as a second input geometry
 the influencing points.
 At this stage not only each influencing point will look for its closest
 tree point but the sets 
\begin_inset Formula $S(v)$
\end_inset

 are populated as well.
 In this implementation the set is stored as a tree node array attribute
 
\family typewriter
@nbrs
\family default
 and will contain the 
\family typewriter
@ptnum
\family default
 for all the influencing points for which the node is the closest of the
 tree nodes.
 This operation can be computationally heavy, therefore the following algorithm
 has been developed aiming to optimize such operations.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\family typewriter
fast_search
\family default
 algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
disegno dei due arraye di cosa arriva nel nodo
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

The algorithm is divided in three parts:
\end_layout

\begin_layout Itemize
an array 
\family typewriter
closest[]
\family default
 is declared to have the same size as the total count of influencing points.
 Starting from the index 
\begin_inset Formula $0$
\end_inset

, the influencing point with 
\family typewriter
@ptnum
\family default
 
\begin_inset Formula $0$
\end_inset

 is processed.
 The point will search for the closest tree node and will store its 
\family typewriter
@ptnum
\family default
 value in the array.
 The process moves to index 
\begin_inset Formula $1$
\end_inset

 and processes the influencing point with 
\family typewriter
@ptnum
\family default
 
\begin_inset Formula $1$
\end_inset

 and so on until the 
\family typewriter
closest[]
\family default
 array is completely populated.
 Given how the array was populated,  the indices of the 
\family typewriter
closest[]
\family default
 array univocally identify the influencing points.
\end_layout

\begin_layout Itemize
two new arrays, 
\family typewriter
ordered_attr[]
\family default
 and 
\family typewriter
ordered_closest[]
\family default
, are created:
\end_layout

\begin_deeper
\begin_layout Itemize
the 
\family typewriter
argsort
\family default
 function applied to the 
\family typewriter
closest[]
\family default
 array will return a list of indices that, if applied to the 
\family typewriter
closest[]
\family default
 will give a sorted sequence in an increasing order.
 In this particular case, the indices represent the influencing points.
 The newly created 
\family typewriter
ordered_attr[]
\family default
 array holds therefore a sorted sequence for the influencing points.
\end_layout

\begin_layout Itemize
the 
\family typewriter
sort
\family default
 function applied to the 
\family typewriter
closest[]
\family default
 will return a sorted array in increasing order.
 This new array is  
\family typewriter
ordered_closest[]
\family default
.
\end_layout

\end_deeper
\begin_layout Itemize

\family typewriter
ordered_attr[]
\family default
 now stores the influencing points, sorted by increasing 
\family typewriter
@id
\family default
 of the tree node they influence (stored in 
\family typewriter
ordered_closest[]
\family default
).
 The algorithm now proceeds to locate the sets 
\begin_inset Formula $S(v)$
\end_inset

 and store them in the proper tree nodes.
 The sets are consecutive chunks of the 
\family typewriter
ordered_attr[]
\family default
 array.
 To tokenize it properly, the 
\family typewriter
ordered_closest[]
\family default
 is used.
 A 
\family typewriter
for
\family default
 loop iterates over the length of the array.
 The value of 
\family typewriter
ordered_attr[i]
\family default
 is stored in a new temporary array 
\family typewriter
nbrs[]
\family default
.
 A check is performed to compare the current element for 
\family typewriter
ordered_closest[]
\family default
 and its consecutive one.
 If the two do not match, it means that the end of the current set 
\begin_inset Formula $S(v)$
\end_inset

 has been reached.
 The temporary array is assigned as 
\family typewriter
@nbrs
\family default
 attribute to the tree node specified in 
\family typewriter
ordered_closest[i]
\family default
.
 The temporary array is cleared for the next set.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\family typewriter
fast_search
\family default
 pseudo-code
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The algorithm proved to be dramatically faster compared to its basic implementat
ion.
 The reader can compare the performances by switching the input for the
 switch node in the 
\begin_inset Quotes eld
\end_inset


\family typewriter
grow_alg/find_neighbour
\family default

\begin_inset Quotes erd
\end_inset

 subnetwork.
 The approach undertaken here also improved Runions algorithm by reducing
 the number of computation required to achieve the result.
\end_layout

\begin_layout Subsubsection
Set fertility for the tree nodes
\end_layout

\begin_layout Standard
Extending Runions' algorithm further, the user can specify the maximum count
 of branches that a node can generate, and from which generation to start
 the branching process.
 This node gives a better control over the final tree structure as it allows
 to achieve a sparser result when reducing the count of children per node.
 By choosing the generation from which to start branching, the user can
 enhance the visual impact of the main trunk structure.
 The 
\shape italic
Wrangle
\shape default
 
\begin_inset Quotes eld
\end_inset


\family typewriter
set_fertility
\family default

\begin_inset Quotes erd
\end_inset

 operates over this constraints: the eligible nodes for the production of
 a new tree node are flagged as fertile.
 Another check is here performed: in the case the node has already reached
 the maximum count of children allowed, the node is flagged as dead and
 becomes inactive for all the remaining iterations of the growth algorithm.
\end_layout

\begin_layout Subsubsection
Calculate new born direction
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset


\family typewriter
newborn_dir
\family default

\begin_inset Quotes erd
\end_inset

 
\shape italic
Wrangle
\shape default
 runs over each tree point that is fed as a first input geometry.
 If the node results to be fertile, the snippet proceeds to retrieve the
 identifiers of the influencing points to that tree node stored in the 
\family typewriter
@nbrs
\family default
 array attribute.
 The set of all the influencing points is fed to the 
\shape italic
Wrangle
\shape default
 as a second input geometry.
 Having the identifiers for the influencing points and the influencing points
 geometry as input, the algorithm can use the identifiers as lookup keys
 to retrieve the position of the influencing points.
 The growth direction for the future newborn is then calculated using 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir"

\end_inset

.
 The normalized 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newborn_dir_normal"

\end_inset

 result is stored in the vector attribute 
\family typewriter
@dir
\family default
 of the tree node.
 This way, the parent node is in charge of holding all the information needed
 to later create and initialize correctly the newborn nodes.
 Before moving on to the next step of the network, the snippet checks for
 degenerate cases for which the magnitude of the 
\family typewriter
@dir
\family default
 vector is 
\begin_inset Formula $0$
\end_inset

, which happens whenever the 
\family typewriter
@nbrs
\family default
 list of influencing points is empty.
 These nodes are declared dead and their fertility flag reset to 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Newborn direction
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Creation of the new node
\begin_inset CommandInset label
LatexCommand label
name "subsec:Creation-of-the-new-node"

\end_inset


\end_layout

\begin_layout Standard
At this stage, the network has gathered all the information needed to create
 the new generation of tree nodes.
 The 
\shape italic
Wrangle
\shape default
 
\begin_inset Quotes eld
\end_inset


\family typewriter
create_new_node
\family default

\begin_inset Quotes erd
\end_inset

 runs over each fertile node of the tree structure.
 The position of the new tree node is determined and the point created using
 the 
\family typewriter
addpoint()
\family default
 Houdini VEX function.
 The 
\family typewriter
_initializeAttribute()
\family default
 function is then invoked to take care of all the parameters of the newborn
 that will make it a viable new tree node.
 The function takes as parameters the 
\family typewriter
@ptnum
\family default
 of the newborn and the 
\family typewriter
@ptnum
\family default
, 
\family typewriter
@dir
\family default
 and 
\family typewriter
@gen
\family default
 of the parent node.
 With these information it populates the attributes for the newborn as described
 in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Initialization-of-newborn"

\end_inset

.
 
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Initialization of newborn tree node
\begin_inset CommandInset label
LatexCommand label
name "alg:Initialization-of-newborn"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

attr_dead = -1;
\end_layout

\begin_layout Plain Layout

Cd = {0, 1, 0};
\end_layout

\begin_layout Plain Layout

fertile = 0;
\end_layout

\begin_layout Plain Layout

generation = parent_generation + 1;
\end_layout

\begin_layout Plain Layout

growdir = parent_dir;
\end_layout

\begin_layout Plain Layout

n_dead = 0;
\end_layout

\begin_layout Plain Layout

parent = parent_id;
\end_layout

\begin_layout Plain Layout

type = "node";
\end_layout

\begin_layout Plain Layout

id = -1;
\end_layout

\end_inset


\end_layout

\end_inset

The colour is initialized as green because the new node does not have any
 children yet.
 This information is later used in the network to find the points on which
 to scatter leaves.
 The 
\family typewriter
@id
\family default
 is temporarily set to a default value and set to its proper value later
 on in the network.
 Compared to Runions' algorithm, the project offers a new approach.
 The original algorithm kept the distance 
\begin_inset Formula $D$
\end_inset

 between consecutive tree nodes as a constant, but in nature younger shrubs
 grow shorter than the previous ones.
 In an attempt to reproduce this natural phenomena, this projects implements
 a scaling algorithm that progressively reduces the 
\begin_inset Formula $D$
\end_inset

 length value across generations.
 The scaling factor is represented as a ramp that the user can manipulate
 to achieve the desired look.
\end_layout

\begin_layout Standard
To set the newborns' 
\family typewriter
@id
\family default
 correctly, these points are separated from the other tree nodes.
 To set the 
\family typewriter
@id
\family default
, the network relies on the total count of tree points as showed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:Set-newborn-id"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Set newborn id
\begin_inset CommandInset label
LatexCommand label
name "alg:Set-newborn-id"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

foreach newborn
\end_layout

\begin_layout Plain Layout

	id = treepointcount + current iteration value
\end_layout

\begin_layout Plain Layout

	update treepoint count as treepointcount + 1
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The reason behind this particular implementation can be found in the peculiar
 nature of the Houdini wrangle nodes.
 The geometry the snippet can access is only the one that is wired in as
 input to the node.
 As explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

, any changes the snippet produces to the geometry will not be reflected
 on the geometry until the node is cooked and fed as input to the next node
 in the network.
 Following this logic, the update of the tree point count, even if it gets
 changed every iteration, will only be written on the geometry when the
 snippet has iterated over all the points.
 The tree point count value used to assign the new 
\family typewriter
@id
\family default
 is therefore the same for each newborn.
\end_layout

\begin_layout Standard
As a final step, the parents' 
\family typewriter
@kids
\family default
 list attribute has to be updated with the newborns' 
\family typewriter
@id
\family default
.
 The separated tree nodes are fed as first input geometry to the 
\begin_inset Quotes eld
\end_inset


\family typewriter
update_parent
\family default

\begin_inset Quotes erd
\end_inset

 
\shape italic
Wrangle
\shape default
.
 The 
\shape italic
Wrangle
\shape default
 will also take as a second input geometry the newborn points.
 For each of the newborns, the snippet will retrieve the @parent (which
 is the @id of that point) value.
 Given the parent's 
\family typewriter
@id
\family default
, the 
\family typewriter
_findPt()
\family default
 function returns a handle to the parent node for which the currently processed
 newborn is appended to the list of children.
 Since the parent now has at least one child, its colour is set to yellow.
 To speed up the performances further, the old tree points are divided further
 so that only the fertile ones, therefore the parents, are fed in the 
\begin_inset Quotes eld
\end_inset


\family typewriter
update_parent
\family default

\begin_inset Quotes erd
\end_inset

 
\family typewriter
Wrangle
\family default
.
\end_layout

\begin_layout Standard
Once this setup is completed, the tree nodes are joined back together.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Newborn network
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
blabla
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Remove attraction points
\end_layout

\begin_layout Standard
As a final step of the growth algorithm, as described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Steps"

\end_inset

, the network has to remove the attraction points that are closer to the
 tree points than the kill distance 
\begin_inset Formula $dk$
\end_inset

.
 Runions explains that greater values for this parameter yield to increasingly
 sparse crowns.
 In his algorithm, the 
\begin_inset Formula $dk$
\end_inset

 is a constant of the whole growth process.
 The tree branching structure presented in his research always resulted
 to be too sparse when it comes to small twigs close to the tree crown shape.
 In an attempt to improve the appearance of such small twigs, the algorithm
 presented in this project scales the value for 
\begin_inset Formula $dk$
\end_inset

 based on a ramp.
 The user can therefore manipulate its value and decrease it for younger
 twigs to achieve better density and more details near the crown surface.
\end_layout

\begin_layout Subsubsection
Preparation to next iteration
\end_layout

\begin_layout Standard
Some attributes of the tree nodes have to be reset to default values in
 order for the next iteration to start in a clean state.
\end_layout

\begin_layout Itemize

\family typewriter
@dir
\family default
 is set back to 
\begin_inset Formula ${0,0,0}$
\end_inset


\end_layout

\begin_layout Itemize

\family typewriter
@nbrs
\family default
 is emptied
\end_layout

\begin_layout Itemize

\family typewriter
@fertile
\family default
 flag is set to 
\begin_inset Formula $0$
\end_inset


\end_layout

\begin_layout Subsubsection
Extra controls
\begin_inset CommandInset label
LatexCommand label
name "subsec:Extra-controls"

\end_inset


\end_layout

\begin_layout Standard
Even though the overall algorithm can produce a wide range of different
 branching structures, the project provides some additional controls:
\end_layout

\begin_layout Itemize
pruning probability: starting from a user-defined generation and killing
 probability threshold value, a random number is calculated for each tree
 node and compared to the killing probability.
 If the random number is smaller than the threshold, the node is set to
 non fertile.
 This small check gives more controls over the density of the branches.
\end_layout

\begin_layout Itemize
pruning by distance: the user can define a minimum distance from the tree
 crown geometry.
 Whenever the distance of a tree node from the crown shape is less than
 that value, the node is set to dead.
\end_layout

\begin_layout Itemize
fix growing angles: it may happen that siblings branches grow too close
 one to each other.
 A new control checks the angle between siblings branches and modifies the
 younger sibling's position if the angle is less than the specified threshold.
 
\end_layout

\begin_layout Subsection
Linking the points
\end_layout

\begin_layout Standard
The relation between parent and children created during the creation of
 new points makes it trivial to link the point together to create the tree
 skeleton.
 The 
\shape italic
Wrangle
\shape default
 
\begin_inset Quotes eld
\end_inset


\family typewriter
connect_points
\family default

\begin_inset Quotes erd
\end_inset

 fetches each point's parent.
 Using the 
\family typewriter
addprim()
\family default
 VEX function a new empty primitive is created.
 The two points are added to that primitive and the link between them is
 created.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Skeleton creation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Cross section evaluation
\begin_inset CommandInset label
LatexCommand label
name "subsec:Cross-section-evaluation"

\end_inset


\end_layout

\begin_layout Standard
In order to create a polygonal mesh around the tree skeleton, the cross
 section has to be evaluated on a per point basis.
 The network implements two different algorithms to fulfil this purpose.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Width setup network
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Ramp scale
\end_layout

\begin_layout Standard
The user is provided with a ramp and a multiplier slider.
 The multiplier scales the amplitude for the whole ramp while the curve
 on the ramp controls the scaling factor for each generation of tree nodes.
 The 
\begin_inset Quotes eld
\end_inset


\family typewriter
ramp_scale
\family default

\begin_inset Quotes erd
\end_inset

 relies on the 
\family typewriter
fit()
\family default
 function to rescale the generation value for the current point to a value
 in the range 
\begin_inset Formula $(0,1)$
\end_inset

.
 The new width is then computed as the product between the ramp value and
 the multiplier.
\end_layout

\begin_layout Subsubsection
Leonardo's Rule
\end_layout

\begin_layout Standard
In his research, Runions relies on 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:shinozaki1964]{Shinozaki et al (1964)}
\end_layout

\end_inset

 to determine the cross-section of the limbs.
 In this model, known as Leonardo's Rule, the diameter of a limb below a
 branching point is determined by the combined cross-section of the limbs
 above.
 The process assumes that all tip points share the same radius 
\begin_inset Formula $r_{0}$
\end_inset

 and proceeds assigning the radii for the other points from the branches'
 tip towards the tree base.
 When two branches with different radius 
\begin_inset Formula $r_{1}$
\end_inset

, 
\begin_inset Formula $r_{2}$
\end_inset

 join at a branching point, the radius 
\begin_inset Formula $r$
\end_inset

 of the supporting limb is given by 
\begin_inset Formula $r^{n}=r_{1}^{n}+r_{2}^{n}$
\end_inset

 where 
\begin_inset Formula $n$
\end_inset

 varies between 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $3$
\end_inset

.
 This work  tries instead to implement the same main formula by processing
 the tree limbs from the root to the tip branches.
 The user can choose the initial value for the root thickness.
 Having the first node's width set, the algorithm iterates over every point,
 in order, finding the children of the node and setting their width based
 on its own width and the total count of children.
 This approach works in this specific implementation because the tree nodes
 have been created in order with increasing 
\family typewriter
@id
\family default
 numbers.
 Therefore, when iterating on them, each node's width has always already
 been set by a previous node.
 Once again, the nature of the 
\shape italic
Wrangle
\shape default
 node does not allow to easily propagate the width from parents to children
 due to the cooking and updating issue explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

.
 To overcome this problem, the 
\shape italic
Wrangle
\shape default
 node only processes one point at the time while the iteration is implemented
 with the loop blocks native in Houdini.
 Since the blocks are in charge of the iteration, the 
\family typewriter
Wrangle
\family default
 gets cooked and the geometry updated.
\end_layout

\begin_layout Subsubsection
Special case: trunk
\begin_inset CommandInset label
LatexCommand label
name "subsec:Special-case:-trunk"

\end_inset


\end_layout

\begin_layout Standard
For a custom trunk input the original ramp algorithm cannot be used as the
 scaling factor is calculated based on the generation number populated during
 the growth algorithm.
 Unfortunately, the trunk points do not have a generation number to rely
 onto.
 Furthermore, the user might want to have a better control over the main
 branches structure as they play a key role in the final appearance of the
 tree.
 As a consequence, the network first sets the width for the trunk and on
 a later stage takes care of the smaller branches generated by the growth
 algorithm.
 The trunk structure is fetched again from its original source.
\end_layout

\begin_layout Standard
As for initializing the 
\family typewriter
@kids
\family default
 attribute as discussed in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Roots"

\end_inset

 the 
\shape italic
Wrangle
\shape default
 node works on the points of each primitive at the time.
 The Houdini loop blocks are in charge of iterating over the primitives
 of the trunk structure.
 The 
\shape italic
Wrangle
\shape default
 creates a ramp and a multiplier for the user to manipulate the width at
 will.
 Before assigning the 
\family typewriter
@width
\family default
 value, a check is performed on the 
\family typewriter
@width
\family default
 value for the first point of the primitive.
 If the 
\family typewriter
@width
\family default
 value is 
\begin_inset Formula $-1$
\end_inset

 (the default one), the primitive being processed is the main trunk.
 The algorithm can assign the 
\family typewriter
@width
\family default
 for the next points of the primitive simply by multiplying the ramp value
 and the multiplier factor.
 If the 
\family typewriter
@width
\family default
 is different than 
\begin_inset Formula $-1$
\end_inset

, the primitive represents a secondary branch and its first point is the
 branching joint between the current branch and its supporting limb.
 Its width is therefore been already set as part of the other branch.
 To blend one branch into its secondary one, the next nodes in the primitive
 are set similarly to the main trunk except that the user-defined multiplier
 is substituted by the first node's width.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Trunk 
\family typewriter
@width
\family default
 initialization
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
As next step the width for the branches generated by the growth algorithm
 has to be set.
 For the ramp scale, the main idea of the artistic-directable ramp is maintained
 although blending the branches with the trunk structure requires some further
 manipulation.
 If for the previous case all the root points shared the same user-defined
 
\family typewriter
@width
\family default
, in this case the width of each node acting as a root has already been
 set.
 The initial condition for this algorithm is represented by a set of tree
 structures with trunk points as roots.
 Each tree has to scale the 
\family typewriter
@width
\family default
 of the branches according to the ramp but each of them should use the 
\family typewriter
@width
\family default
 of its own root point as a multiplier to achieve the desired blending effect.
 This would be trivial with a recursive algorithm: ideally one should iterate
 on each child of the root and set the 
\family typewriter
@width
\family default
.
 Each child then acts as root of its own sub-tree and the operation is repeated.
 Unfortunately Houdini VEX does not support recursive function calls at
 the current time.
 The algorithm has therefore been converted from recursive to iterative
 by using a stack data structure as a support.
 The root node stores its children in the stack.
 A 
\family typewriter
while
\family default
 loop iterates over the stack.
 For each iteration, the last added node is removed from the stack and is
 processed.
 After setting its own 
\family typewriter
@width
\family default
 value, the node pushes its children in the stack and a new iteration begins.
 The 
\family typewriter
while
\family default
 loop only stops when the stack is empty.
 Using the stack as support data structure, the described process successfully
 simulates a depth-first recursive algorithm and overcomes the updating
 geometry problem explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Wrangle-Node"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Trunk 
\family typewriter
@width
\family default
 non-recursive initialization
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trunk Skinning
\end_layout

\begin_layout Standard
After building the tree structure, each branch is re-sampled to gain more
 control over the final look.
 The 
\emph on
point jitter
\emph default
 SOP helps moving from straight branches curves to a more gnarly and varied
 silhouette.
 Its effect gets easily out of control causing the geometry to change too
 drastically.
 To counterbalance the sharp angles generated by the 
\shape italic
jitter
\shape default
, the 
\emph on
smooth
\emph default
 SOP interpolates these angles and achieves a more natural look.
 The 
\emph on
polywire
\emph default
 SOP creates the polygonal mesh around the tree skeleton using the 
\family typewriter
@width
\family default
 attribute set in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Cross-section-evaluation"

\end_inset

 as cross-section value.
 A second 
\emph on
smooth
\emph default
 SOP interpolates the thickness values at the branching nodes.
 As a final step, the user can decide whether to color the trunk with a
 
\emph on
color
\emph default
 SOP or input a custom shader.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree skinning
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Leaves
\end_layout

\begin_layout Standard
In nature, trees produce leaves only at the very tip of the branching structure.
 To replicate this phenomenon the network isolates all those nodes of the
 tree who do not have any children.
 The leaves are then copied on those points by using the 
\emph on
copy_stamp
\emph default
 node.
 For 
\emph on
copy_stamp
\emph default
 to work properly, the normal direction has to be set for the tree nodes.
 The 
\emph on
point
\emph default
 SOP activates an edge force on these point.
 The edge force is directed along the edge direction which is stored in
 the 
\family typewriter
edge_dir
\family default
 built-in variable for points in Houdini.
 With a 
\shape italic
VOP subnetwork
\shape default
 the 
\family typewriter
edge_dir
\family default
 is copied as value for the normal direction of the points.
\end_layout

\begin_layout Standard
The user can decide to either use the default geometry or to input a custom
 model for the leaves.
 For the default ones, some 
\emph on
copy_stamping
\emph default
 expressions randomize the roll and pitch within a set range of values on
 a per instance basis.
 For the custom geometry instead, a control is given to specify the number
 of leaves per tree node.
 The 
\emph on
copy_and_transform
\emph default
 evenly spreads the leaves radially by dividing 360 degrees by the number
 of leaf instances specified by the user.
\end_layout

\begin_layout Standard
The user can choose whether to use a plain color or apply a custom shader.
 While the default geometry is ready to shade, the user has to make sure
 to prepare the custom geometry for the shading process using the 
\emph on
UV_project
\emph default
 Houdini node before feeding the leaf object as input to the network.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Tree skinning
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Problems and attempted solutions
\end_layout

\begin_layout Subsection
Determine S(v) set
\end_layout

\begin_layout Standard
At very early stages of production, the 
\begin_inset Formula $S(v)$
\end_inset

 set has been implemented as a Houdini group.
 Groups in Houdini are similar to a boolean variable associated to each
 point of the geometry that specifies the membership of the point to the
 group.
 Having n tree nodes, the system would have to store n groups.
 After a few couple of iteration however, the number of different groups
 resulted to be inefficient to use.
 At this stage as well, the sets were processed in a for_each subnetwork
 that unfortunately caused issues of duplicated geometry which lead to frequent
 crashes of the scene.
 As a solution, the current data system relying on the attribute @nbrs instead
 of the groups was adopted.
\end_layout

\begin_layout Subsection
Branching collisions
\end_layout

\begin_layout Standard
For some cases, especially for the very first generations, it may happen
 that branches tend to grow too clustered together.
 The 
\family typewriter
fix_newborn_dir
\family default
, as explained in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Extra-controls"

\end_inset

, takes care of these particular scenarios moving the newborn to a minimum
 distance angle from its closest sibling.
 To achieve this result, the algorithm presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Angle-correction"

\end_inset

 was used.
\end_layout

\begin_layout Subsubsection
IsoOffset: from polygons to volumes
\end_layout

\begin_layout Standard
The IsoOffset node converts the user input crown shape to a volume that
 can be seeded with attraction points.
 Unfortunately the conversion leads to some artefacts such as horizontal
 lines exceeding or carving the original geometry.
 Different solution have been tried such as changing the volume conversion
 method but none of them proved to be succesfull for more than a few cases.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Artefacts caused by the 
\shape italic
IsoOffset
\shape default
 node
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Scaling
\end_layout

\begin_layout Standard
As it concerned the Leonardo's scaling system, the newly proposed approach,
 even though it results easier to implement, can lead to chopped branches.
 Starting from the roots and proceding to the top from a user defined initial
 width value, whenever a branch dies due to the lack of space or the pruning
 system, it looks truncated.
 Similar issue arises for the ramp scaling system.
 Again, if a branch dies in an early generation, its width will be the same
 as the other branches that kept scaling down along the new generated branches.
\end_layout

\begin_layout Standard
A solution may be found for the first algorithm with a careful manipulation
 of the tree points to process them backwards from the tips to the root
 as suggested originally by Runion.
 Such solution would most likely not work properly for a custom trunk with
 custom thickness.
 The blending between automatically generated branches and user input ones
 would probably have to be achieved manually.
 As far as it concerns the ramp scale, a solution could not be found during
 this project and the problem remains open for future work.
\end_layout

\begin_layout Section
Performances
\end_layout

\begin_layout Standard
An iterative system that handles a huge amount of geometries can result
 to be extremely slow.
 Even though the performances were not the primary focus of this project,
 a considerable effort has been made to make the network as fast as possible.
 The reason for investing in the performances relies in the nature of the
 tool: The project presented aims to be an easy and quick-to-setup tool
 to create procedural and art-directable trees.
 If the tool were to require several minutes to produce a result, the user
 would find it hard to compare two successive attempts at tuning the parameters
 to get the desired look.
 At very early stages of development, cooking a 30-iterations tree took
 up to 40 minutes.
 Grouping the geometry points involved in the space colonization algorithm
 into nodes and attraction points helped speeding up the execution time.
\end_layout

\begin_layout Standard
Even though this change improved the performances, the network still spent
 an excessive amount of time processing the 
\family typewriter
\shape italic
\emph on
find_neighbours
\family default
\shape default
\emph default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Finding-neighbours"

\end_inset

 and the 
\family typewriter
\shape italic
\emph on
setting_id
\family default
\shape default
\emph default
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Creation-of-the-new-node"

\end_inset

 algorithms.
 Dividing the tree nodes respectively into newborns, parents and old tree
 nodes improved the performances dramatically since the search loop was
 only to iterate over a few hundred points instead of a few thousand.
\end_layout

\begin_layout Standard
The biggest speedup was however achieved by optimizing the algorithm for
 the research of neighbours.
 In its first version, each iteration of the growth algorithm required the
 same node to be cooked over 20000 times in order to update the geometry
 points.
 The new approach presented in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Finding-neighbours"

\end_inset

 made the real difference in terms of the final execution time.
\end_layout

\begin_layout Standard
Even though the execution time still heavily depends on parameters such
 as the total number of attraction points, iterations, 
\begin_inset Formula $D$
\end_inset

, 
\begin_inset Formula $di$
\end_inset

, 
\begin_inset Formula $dk$
\end_inset

, the average cooking time stabilized around 15 s for 40-iterations trees.
\end_layout

\begin_layout Section
Conclusions
\end_layout

\begin_layout Standard
The described implementation successfully reproduces the approach presented
 by Runions.
 The volume of the tree crown is represented as a set of attraction points
 which get removed as the branches approach them.
 Parameters specify the granularity of the empty space, the search distance
 from which the branches can sense it and how deep the empty space sensed
 can be penetrated by the branches.
 Further controls manipulate the distribution of the attraction points allowing
 for a greater density of branches near the surface of the tree crown.
 Information of the hierarchy of branches offers control over their different
 sizes.
 The final result produced a realistic branching structure even without
 any post-processing of the skeleton.
 In some cases, post-processing operations such as resampling the branches
 or applying random noise to the tree points can lead to a more natural
 look of the final artefact.
 The project builds on Runion's research to add more controls over the branching
 structure by varying the parameter values on-the-fly and introducing small
 corrections such as the pruning system and the angle correction.
 A fully art-directable scaling system for the branch size has been developed
 alongside the one proposed in the original paper.
\end_layout

\begin_layout Standard
The tool successfully integrates a user-defined main skeleton with the geometry
 produced by the space colonization algorithm fulfilling the purpose of
 having a tool for art-directable procedural vegetation.
 The implementation also proved to be able to handle a wide range of scenarios:
 it can grow trees from one or multiple sources at once, a custom trunk
 can be used as starting point for the space colonization algorithm, the
 generated geometry reacts to the surrounding obstacles by either avoiding
 them or using them as objects to crawl onto in a vine-like behaviour.
 When tested for rendering, the produced mesh unwraps correctly.
\end_layout

\begin_layout Subsection
Future work
\end_layout

\begin_layout Standard
The system successfully simulates the competition for space that characterizes
 tree structures.
 As a future enhancement, competition for light could be introduced as well.
 The light influence could probably solve the issue of having a too sparse
 foliage.
 To address the same problem, the system could use a proxy or billboards
 instead of actual geometry that expands only at render time.
 That would maintain the scene responsive while improving the final look.
\end_layout

\begin_layout Standard
Other problems remain open for future research.
 The method proposed in this project creates a believable mature tree.
 The project could be significantly improved by being able to simulate the
 growth process that leads from young shrubs to the mature tree.
\end_layout

\begin_layout Standard
A simulation of breeze through the leaves or wind interacting with the tree
 would improve the overall result and could be accomplished using the Houdini
 
\emph on
Wire
\emph default
 solver.
\end_layout

\begin_layout Standard
For scenes populated by a large number of plants, the current geometry might
 be too heavy.
 Implementing a procedural LOD for the polygonal mesh and an automatic pruning
 of the small twigs based on the distance from the camera could make the
 viewport more responsive and the rendering quicker.
\end_layout

\begin_layout Part*
Appendix
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{Appendix}
\end_layout

\end_inset


\end_layout

\begin_layout Section*
L-Systems
\begin_inset CommandInset label
LatexCommand label
name "sec:L-Systems"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{L-System}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:lindenmayer1996]{L-Systems}
\end_layout

\end_inset

 (Lindenmayer Systems) were conceived as a theory for plant development.
 The key idea of L-System is rewriting.
 An L-System is a rewriting system and a formal grammar.
 A 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:fgrammar]{formal grammar}
\end_layout

\end_inset

 is a set of rules for rewriting strings in a formal language.
 A rewriting system defines, in this case, methods for replacing substrings
 with other symbols.
 An L-System consists of:
\end_layout

\begin_layout Itemize
Alphabet: set of symbols used to create strings.
 These symbols can either be replaceable or constant.
\end_layout

\begin_layout Itemize
Axiom: string or symbol to start the production, made of elements of the
 alphabet.
\end_layout

\begin_layout Itemize
Production rules: rules to replace and expand symbols or substrings with
 other sequences of symbols.
\end_layout

\begin_layout Standard
In L-Systems, production rules are applied in parallel and simultaneously
 in each generation.
 In this sense, L-System differ from formal languages in which only one
 rule is applied per iteration.
\end_layout

\begin_layout Standard
L-Systems can be classified as:
\end_layout

\begin_layout Itemize
Context-free: if every production rule only refer to an individual symbol.
\end_layout

\begin_layout Itemize
Context sensitive: production rules refer not only on individual symbols
 but also to groups of symbols.
\end_layout

\begin_layout Itemize
Deterministic: the production set provides one and one only production rule
 for each symbol.
 An L-System that is deterministic and context-free is usually referred
 as D0L System.
\end_layout

\begin_layout Itemize
Stochastic: several production rules are given for each symbol, each iteration
 one of them is chosen based on a certain probability value.
\end_layout

\begin_layout Standard
A visual representation of the produced string can be achieved by employing
 the 
\begin_inset Quotes eld
\end_inset

turtle
\begin_inset Quotes erd
\end_inset

 interpretation, that translates strings into graphical commands.The turtle
 interpretation is based on the following commands:
\end_layout

\begin_layout Itemize
F: move forward a step of length 
\begin_inset Formula $d$
\end_inset

.
 Draw a line between current and previous positions.
\end_layout

\begin_layout Itemize
f: move forward a step of length 
\begin_inset Formula $d$
\end_inset

 without drawing a line.
\end_layout

\begin_layout Itemize
+: turn left by an angle of 
\begin_inset Formula $\delta.$
\end_inset


\end_layout

\begin_layout Itemize
-: turn right by an angle of 
\begin_inset Formula $\delta.$
\end_inset


\end_layout

\begin_layout Standard
Given their recursive nature, L-Systems can be used to generate self-similar
 fractals.
\end_layout

\begin_layout Section*
F 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:ferianiCGI]{ractals}
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sec:Fractals"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Fractals}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The term 
\begin_inset Quotes eld
\end_inset

fractal
\begin_inset Quotes erd
\end_inset

 derives from the latin 
\emph on
fractus
\emph default
, which means 
\begin_inset Quotes eld
\end_inset

broken
\begin_inset Quotes erd
\end_inset

.
 The word was firstly introduced by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:Mendelbrot1982]{Mandelbrot (1982)}
\end_layout

\end_inset

.
 In Mandelbrot's words, a fractal is 
\end_layout

\begin_layout Quote
\begin_inset Quotes eld
\end_inset

a rough or fragmented geometric shape that can be split into parts, each
 of which is (at least approximately) a reduced-size copy of the whole.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
The main features of a fractal are then, as per definition:
\end_layout

\begin_layout Itemize
Self-similarity: each part is a scaled size copy of the whole.
\end_layout

\begin_layout Itemize
Fine structure at small scale.
\end_layout

\begin_layout Itemize
Recursive definition.
\end_layout

\begin_layout Section*
Angle correction
\begin_inset CommandInset label
LatexCommand label
name "sec:Angle-correction"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Angle correction}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
Whenever two sibling branches grow too close together, the network provides
 a way of moving the youngest one from the sibling so that the angle between
 them is bigger or equal than a certain user defined value.
 We call 
\begin_inset Formula $\hat{a}$
\end_inset

 the moving vector and 
\begin_inset Formula $\hat{b}$
\end_inset

 the still vector.
 
\begin_inset Formula $\hat{a}$
\end_inset

, 
\begin_inset Formula $\hat{b}$
\end_inset

 are defined as follows.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{a}=(a_{x},a_{y},a_{z})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{b}=(b_{x},b_{y},b_{z})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mid\hat{a}\mid=\mid\hat{b}\mid=1
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It is known that 
\begin_inset Formula $cos\vartheta=\frac{\hat{a}\cdot\hat{b}}{\mid\hat{a}\mid\mid\hat{b}\mid}=\hat{a}\cdot\hat{b}$
\end_inset

 from which follows that 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\vartheta=cos^{-1}(\hat{a}\cdot\hat{b})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
One can now decompose 
\begin_inset Formula $\hat{a}$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{//}=cos\vartheta\hat{b}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{\bot}=\hat{a}-a_{//}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
It is also known that
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
tan\vartheta=\frac{\mid a_{//}\mid}{\mid a_{\bot}\mid}\label{eq:tan_theta}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The user defines the new angle between the two vector as 
\begin_inset Formula $\vartheta_{0}$
\end_inset

.
 One can therefore calculate a new 
\begin_inset Formula $\mid a_{\bot}^{\prime}\mid$
\end_inset

 that satisfies the following equation
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mid a_{\bot}^{\prime}\mid=\mid a_{//}\mid tan\vartheta_{0}\label{eq:new_perp}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
By combining 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:tan_theta"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:new_perp"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a_{\bot}^{\prime}=a_{\bot}(\frac{\mid a_{//}\mid tan\vartheta_{0}}{\mid a_{\bot}\mid})
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
One can therefore define the new position 
\begin_inset Formula $\hat{a}^{\prime}$
\end_inset

 as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
a^{\prime}=a_{//}+a_{\bot}^{\prime}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
and its unit vector as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\hat{a}^{\prime}=\frac{a^{\prime}}{\mid a^{\prime}\mid}
\end{equation}

\end_inset


\end_layout

\begin_layout Section*
Flowers
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{section}{Flowers}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
To enrich this project another small and simple tool has been developed
 to create procedural flowers., taking inspiration by the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:perez2017]{Perez (2017)}
\end_layout

\end_inset

 work on fern plants and the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
hyperref[par:dalvi2015]{Dalvi (2015)}
\end_layout

\end_inset

 work on vines.
 The network for this tool is divided in three big areas, respectively for
 the stem, the petals and the stamen.
\end_layout

\begin_layout Subsection*
Stem
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{Stem}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The network provides a full customization on the stem geometry.
 The user can either modify the default line geometry that acts as a skeleton
 for the stem or input his own line.
 The 
\emph on
jitter
\emph default
 node is used to manipulate the stem points by adding custom noise on their
 position so that the final artefacts looks more natural.
 Since the 
\shape italic
jitter
\shape default
 displacement is based on a random seed, that seed can be used to create
 different models for the same flower specie when populating a scene.
 A control is given so that the stem can be bent at will.
 In a process similar to the one described in 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Special-case:-trunk"

\end_inset

 the cross-section of the stem is function of the 
\family typewriter
@ptnum
\family default
, a ramp then determines the value for the cross-section of the specific
 point.
 The 
\emph on
polyreduce
\emph default
 node can change the total count of polygon for the stem geometry.
 In a future, that node could be used to generate procedural LOD based on
 the distance from the camera looking at the scene.
 As a final refinement, the user can benefit from a 
\emph on
sculpt
\emph default
 tool to add more refinement to the stem polygonal mesh.
\end_layout

\begin_layout Subsection*
Stamen Base
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{Stamen Base}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The stamen base has been modelled as a general shape that can produce visually
 appealing results for a wide variety of flower species.
 If in need of more refinement, the user can either sculpt more subtitle
 details with the 
\emph on
sculpt
\emph default
 tool or use a custom geometry.
 As for the stem, a 
\emph on
polyreduce
\emph default
 node is provided to allow for a future procedural LOD.
\end_layout

\begin_layout Subsection*
Stamen Filaments
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{Stamen Filaments}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
The anatomy of flowers can vary greatly if we compare, for example, a sunflower
 with a lily.
 Whereas a sunflower model can be easily achieved using the modelling of
 the stamen base discussed in the previous paragraph, a lily-like flower
 has very long stamens at the centre of the petal crown.
 To reproduce such feature the stamen filaments have been modelled alongside
 the stamen base.
 The geometry, as for the stem, starts from a simple curve.
 Custom bending is also available to the user to change the stamen appearance
 at will.
 A 
\emph on
copy_stamping
\emph default
 expression manages to create slightly different instances of such filament
 for a total amount defined by the user.
\end_layout

\begin_layout Subsection*
Petals
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{subsection}{Petals}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
As for every part of the network, the user can decide to either use the
 default geometry or select a custom model.
 Petals are scattered on top of the stamen base.
 The user, based on the stamen base geometry, can decide a minimum level
 and a maximum level for the petals to be scattered on based on the angles
 as follows.
 A value 
\begin_inset Formula $\vartheta$
\end_inset

 on a per point basis is calculated as
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\vartheta=tan^{-1}\frac{p_{y}}{\sqrt{p_{x}^{2}+p_{z}^{2}}}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\noindent
The angle is compared to a minimum and maximum value defined by the user.
 The points with 
\begin_inset Formula $\vartheta$
\end_inset

 falling in the specified range are used as sources for the petals.
\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{Acknowledgments}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
blablabla3
\end_layout

\begin_layout Part*

\lang english
\begin_inset Newpage cleardoublepage
\end_inset

References
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
addcontentsline{toc}{part}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:cieri2016"

\end_inset


\end_layout

\begin_layout Standard
Cieri, S., Muraca, A., Schwank, A., Preti, F., Micilotta, T., 2016.
 The Jungle Book: Art-Directing Procedural Scatters in Rich Environments.
 
\shape italic
DigiPro 16
\shape default
, 23 - 23 July Anaheim, CA.
 New York: ACM, 57-59.
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:dalvi2015"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Dalvi, R., 2015.
 
\shape italic
Creating animated ivy in Houdini - Tutorial 001
\shape default
.
 Video.
 youtube.
\end_layout

\begin_layout Standard
\noindent

\lang english
Available from: https://www.youtube.com/watch?v=Uhr3HjHW_oU
\end_layout

\begin_layout Standard
\noindent

\lang english
[Accessed 21 May 2017].
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:ferianiCGI"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Feriani, M., 2017, 
\shape italic
Background Research for Ice Growth Simulation CGI Technologies
\shape default
, MSc CGITools Report.
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:perez2017"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Filmmakerperez, 2017.

\shape italic
 Houdini Tutorial - Procedurally Modeling 3D Plants
\shape default
.
 Video.
 youtube.
\end_layout

\begin_layout Standard
\noindent

\lang english
Available from: https://www.youtube.com/watch?v=K0qKWRBgwCY&t=1198s
\end_layout

\begin_layout Standard
\noindent

\lang english
[Accessed 16 May 2017].
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset label
LatexCommand label
name "par:honda1971"

\end_inset


\end_layout

\begin_layout Standard
\noindent
Honda, H., 1971.
 Description of the form of trees by the parameters of the tree-like body
 : effects of the branching angle and the branch length on the shape of
 the tree-like body.
 J.
 Theoret.
 Biol, 31, 331-338.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:houdini2017"

\end_inset


\end_layout

\begin_layout Standard
\noindent

\lang english
Power Up Your Houdini Skills with SideFX, 2017.
 Making the Last Bastion.
 
\shape italic
3D World Magazine
\shape default
, 20 June 2017, Available from: https://issuu.com/futurepublishing/docs/houdini_i
ssuu [Accessed 24 July 2017].
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:ijiri2006"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Ijiri, T., Owada, S., Igarashi, T., 2006.
 The Sketch L-System: Global Control of Tree Modeling Using Free-form Strokes.
 
\shape italic
6th International Symposium Smart Graphics
\shape default
, 23-25 July, Vancouver, Canada.
 138-146.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:keim2016"

\end_inset


\end_layout

\begin_layout Standard
Keim, H., Simmons, M., Teece, D., Reisweber, J., Drakeley, S., 2016.
 Art-Directable Procedural Vegetation in Disneys Zootopia.
 
\shape italic
SIGGRAPH 16
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:Mandelbrot1982"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Mandelbrot, B.
 B., 1982.
 
\shape italic
The fractal geometry of nature
\shape default
.
 W.
 H.
 Freeman and Company.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:melson2016"

\end_inset


\end_layout

\begin_layout Standard
Melson, T., 2016.
 Cant See The Jungle For The Trees.
 
\shape italic
SIGGRAPH 16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:oppenheimer1986"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Oppenheimer, P., 1986.
 Real Time Design and Animation of Fractal Plants and Trees.
 Computer Graphics Proceedings, Annual Conference Series, 18-22 August,
 Dallas.
 Dallas, Texas: ACM SIGGRAPH, 55-64.
\end_layout

\begin_layout Standard
\noindent
\begin_inset CommandInset label
LatexCommand label
name "par:lindenmayer1996"

\end_inset


\end_layout

\begin_layout Standard
\noindent
Prusinkiewicz, P., Lindenmayer, A., 1990.
 
\shape italic
The Algorithmic Beauty of Plants
\shape default
.
 New York: Springer-Verlag.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:rodkaew2003"

\end_inset


\end_layout

\begin_layout Standard
Rodkaew, Y., Chongstitvatana, P., Siripani, S., Lursinsap, S., 2003.
 Particle Systems for Plant Modeling.
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:runions2005"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Runions A., Fuhrer M., Lane B., Federl P., Rolland-Lagan A.-G., Prusinkiewicz
 P., 2005.
 Modeling and visualization of leaf venation patterns.
 
\shape italic
ACM Transactions on Graphics
\shape default
, 24(3), 705-711.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:runions2007"

\end_inset


\end_layout

\begin_layout Standard
Runions, A., Lane, B., Prusinkiewicz, P., 2007.
 Modeling Trees with a Space Colonization Algorithm.
 In: Ebert, D., Mrillou, S., 
\shape italic
NPH'07 Proceedings of the Third Eurographics conference on Natural Phenomena
\shape default
, 4 September 2007, Prague.
 Aire-la-Ville: Eurographics Association, 63-70.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:schwank2016"

\end_inset


\end_layout

\begin_layout Standard
Schwank, A., James, C.
 J., Milciotta, T., 2016.
 The Trees of The Jungle Book.
 
\shape italic
SIGGRAPH 16 Talks
\shape default
, 24-28 July 2016.
 Anaheim, CA: ACM
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:shek2010"

\end_inset


\end_layout

\begin_layout Standard
Shek, A., Lacewell, D., Selle, A., Teece, D., Thompson, T., 2010.
 Art-directing Disney's Tangled procedural trees.
 
\shape italic
SIGGRAPH 2010 Talks
\shape default
, 26 - 30 July Los Angeles.
 New York: ACM, 53.
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:shinozaki1964"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Shinozaki, K., Yoda, K., Hozumi, K., Kira, T., 1964.
 A quantitative analysis of plant form  the pipe model theory.
 
\shape italic
Japanese Journal of Ecology
\shape default
, 14 (3), 97104.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:soares2016"

\end_inset


\end_layout

\begin_layout Standard
Soares, O., Moser, M., Aalbers, F., 2016.
 Vegetation Choreography in The Good Dinosaur.
 
\shape italic
SIGGRAPH 16 Talks
\shape default
, 24 - 28 July Anaheim, CA.
 New York: ACM
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:wrangle"

\end_inset


\end_layout

\begin_layout Standard

\lang english
SideFX, 2017.
 
\shape italic
Attribute Wrangle
\shape default
.
 sidefx.com, Available from: http://www.sidefx.com/docs/houdini/nodes/sop/attribwra
ngle [Accessed 14 August 2017].
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:wang2008"

\end_inset


\end_layout

\begin_layout Standard
Wang, C., Yang, K., Han, D., 2008.
 New Modeling Method for Trees.
 
\shape italic
2008 International Conference on Advanced Computer Theory and Engineering
\shape default
, 20-22 December 2008 Phuket.
 Los Vaqueros Circle: Institute of Electrical and Electronics Engineers
 ( IEEE ), 633-637.
\end_layout

\begin_layout Paragraph*
\begin_inset CommandInset label
LatexCommand label
name "par:weber1995"

\end_inset


\end_layout

\begin_layout Standard
Weber, J., Penn, J., 1995.
 Creation and Rendering of Realistic Trees.
 
\shape italic
22nd International ACM Conference on Computer Graphics and Interactive Technique
s
\shape default
, 6 - 11 August 1995 Los Angeles.
 New York: ACM, 119 - 128.
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:graph"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Wikipedia, 2017.
 
\shape italic
Graph theory
\shape default
.
 wikipedia.org, Available from: https://en.wikipedia.org/wiki/Graph_theory
 [Accessed 14 August 2017].
\end_layout

\begin_layout Paragraph*

\lang english
\begin_inset CommandInset label
LatexCommand label
name "par:fgrammar"

\end_inset


\end_layout

\begin_layout Standard

\lang english
Wikipedia, 2017.
 
\shape italic
Formal grammar
\shape default
.
 wikipedia.org, Available from: https://en.wikipedia.org/wiki/Formal_grammar
 [Accessed 14 August 2017].
\end_layout

\end_body
\end_document
